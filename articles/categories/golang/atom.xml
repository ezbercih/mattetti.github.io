<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: golang | Matt Aimonetti]]></title>
  <link href="http://mattetti.github.com/mattetti/articles/categories/golang/atom.xml" rel="self"/>
  <link href="http://mattetti.github.com/mattetti/"/>
  <updated>2013-07-04T11:58:59-07:00</updated>
  <id>http://mattetti.github.com/mattetti/</id>
  <author>
    <name><![CDATA[Matt Aimonetti]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Golang multipart file upload example]]></title>
    <link href="http://mattetti.github.com/mattetti/posts/2013/07/01/golang-multipart-file-upload-example/"/>
    <updated>2013-07-01T22:28:00-07:00</updated>
    <id>http://mattetti.github.com/mattetti/posts/2013/07/01/golang-multipart-file-upload-example</id>
    <content type="html"><![CDATA[<p>The Go language is one of my favorite programming languages. However,
sometimes doing simple things can seem a bit harder than it should.
However, most of the time, the problem is just to find out how to
do things the easy way. While Go's documention isn't bad, the real key
to finding out how to do things is often to look at the <a href="http://golang.org/src/pkg/mime/multipart/">source code</a> and
the <a href="http://golang.org/src/pkg/mime/multipart/multipart_test.go">test suite</a>.</p>

<p>I'm not yet super familiar with all the std lib packages, so when I
wanted to test my Go web services, I wrote a few lines of code to create
a multipart file upload function that was building the body from scratch.
Once I was done messing with the various headers, boundary protocol etc..
I started testing some edge cases, I found some bugs in my code.
Looking at Go's packages, I realized that all the tools were already
available for me to use. I was just lacking a good example. Walking
through the test suite I finally figured out how to write a simple
multipart file upload example with some extra query params.</p>

<p>Hopefully this example will be helpful to some of you.</p>

<p>```go
package main</p>

<p>import (</p>

<pre><code>"bytes"
"fmt"
"io"
"log"
"mime/multipart"
"net/http"
"os"
"path/filepath"
</code></pre>

<p>)</p>

<p>// Creates a new file upload http request with optional extra params
func newfileUploadRequest(uri string, params map[string]string, paramName, path string) (*http.Request, error) {</p>

<pre><code>file, err := os.Open(path)
if err != nil {
    return nil, err
}
file.Close()

body := new(bytes.Buffer)
writer := multipart.NewWriter(body)
part, err := writer.CreateFormFile(paramName, filepath.Base(path))
if err != nil {
    return nil, err
}
_, err = io.Copy(part, file)

for key, val := range params {
    _ = writer.WriteField(key, val)
}
err = writer.Close()
if err != nil {
    return nil, err
}

return http.NewRequest("POST", uri, body)
</code></pre>

<p>}</p>

<p>func main() {</p>

<pre><code>path, _ := os.Getwd()
path += "/test.pdf"
extraParams := map[string]string{
    "title":       "My Document",
    "author":      "Matt Aimonetti",
    "description": "A document with all the Go programming language secrets",
}
request, err := newfileUploadRequest("https://google.com/upload", extraParams, "file", "/tmp/doc.pdf")
if err != nil {
    log.Fatal(err)
}
client := &amp;http.Client{}
resp, err := client.Do(request)
if err != nil {
    log.Fatal(err)
} else {
    var bodyContent []byte
    fmt.Println(resp.StatusCode)
    fmt.Println(resp.Header)
    resp.Body.Read(bodyContent)
    resp.Body.Close()
    fmt.Println(bodyContent)
}
</code></pre>

<p>}
```</p>

<p><a href="https://gist.github.com/mattetti/5914158">Example's source code on GitHub</a></p>

<p>All the work is done in the <code>newfileUploadRequest</code> function and
really, the <code>mime/multipart</code> package hides all the complexity of
creating a multipart request.</p>

<p>The key is to set a new <code>multipart.Writer</code>:</p>

<p><code>go
writer := multipart.NewWriter(body)
</code></p>

<p>The writer will do all the work and will write directly to our body (which itself is a buffer of bytes).</p>

<p>We then create a part for the file form entry with the name of the file
param and the name of the file (that we extracted using the <code>path/filepath</code>
package).
We need to add the content of the file to the file part, we use the
<code>io.Copy()</code> to do so. In the first version of this article, I had used
<code>io/ioutil</code> <code>Readall</code> to read the content of the file (see code <a href="https://gist.github.com/mattetti/5914158/f4d1393d83ebedc682a3c8e7bdc6b49670083b84">here</a>).
However a few readers rightfully mentioned that I should instead copy
content from the file to the part instead of temporarily loading the content of
the file in memory.</p>

<p><code>go
part, _ := writer.CreateFormFile(paramName, filepath.Base(path))
_, err = io.Copy(part, file)
</code></p>

<p>The <code>multipart.Writer</code> takes care of setting the boundary and formating
the form data for us, nice isn't it?!</p>

<p>Then for any extra params passed as a map of string keys to string
value, we use another function of the <code>multipart.Writer</code> type:</p>

<p><code>go
writer.WriteField(key, val)
</code></p>

<p>Once again, the writer takes care of creating the right headers, and to
add the passed value.</p>

<p>At this point, we just need to close our writer and use our body to
create a new request.</p>

<p><code>go
writer.Close()
req, _ := http.NewRequest("POST", uri, body)
</code></p>

<p>One last thing before triggering our request, we need to set the header
that contains the content type including the boundary being used.
Once again, the Go lib has us covered:</p>

<p><code>go
req.Header.Add("Content-Type", writer.FormDataContentType())
</code></p>

<p>As a reference, here is the generated body:</p>

<p>```
--0d940a1e725445cd9192c14c5a3f3d30ea9c90f1f5fb9c08813b3fc2adee
Content-Disposition: form-data; name="file"; filename="doc.pdf"
Content-Type: application/octet-stream</p>

<p>%PDF-1.4
%????
4 0 obj
&lt;&lt;/Type /Catalog
// removed for example
trailer
&lt;&lt;/Size 18
/Root 4 0 R</p>

<blockquote><blockquote><p>startxref
45054
%%EOF
--0d940a1e725445cd9192c14c5a3f3d30ea9c90f1f5fb9c08813b3fc2adee
Content-Disposition: form-data; name="title"</p></blockquote></blockquote>

<p>My Document
--0d940a1e725445cd9192c14c5a3f3d30ea9c90f1f5fb9c08813b3fc2adee
Content-Disposition: form-data; name="author"</p>

<p>Matt Aimonetti
--0d940a1e725445cd9192c14c5a3f3d30ea9c90f1f5fb9c08813b3fc2adee
Content-Disposition: form-data; name="description"</p>

<p>A document with all the Go programming language secrets
--0d940a1e725445cd9192c14c5a3f3d30ea9c90f1f5fb9c08813b3fc2adee--</p>

<p>```</p>

<p>Golang might not be as high level as Ruby or Python, but it's not too
far off and it certainly comes with some great std libs.
I know I recently caught myself writing a lot of small scripts in Go,
something I used to do in Ruby. I think this is mainly due to the
fact that Go is compiled, designed for concurrency, has great std libs and
is quite easy to write.</p>

<p><em>Hopefully this code sample illustrates how easy Go can be and can also
serve as a reference point if you are looking for a way to do multipart
upload.</em></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using Go vs Ruby for web APIs]]></title>
    <link href="http://mattetti.github.com/mattetti/posts/2013/06/23/using-go-vs-ruby-for-web-apis/"/>
    <updated>2013-06-23T09:50:00-07:00</updated>
    <id>http://mattetti.github.com/mattetti/posts/2013/06/23/using-go-vs-ruby-for-web-apis</id>
    <content type="html"><![CDATA[<p>A few days ago, I was wondering if using <a href="http://golang.org/">Go</a> would be worth it when developing new web APIs.
I obviously knew that Go would be faster than Ruby, but I wasn't sure
how much faster. I also wondering about the amount of work required to
write get a full API implemented.</p>

<p>I therefore wrote the same web API in Ruby (using Rails) and in Go (at
first using Revel and then rewriting it without a framework since Go's
std lib have everything one might need).
The API spec was simple:
* extract an authorization token contained in the request header
* use the token to query a MySQL database
* respond by sending back the MySQL row in json format
* return 401 if the token isn't value</p>

<p>I didn't try to optimize the Ruby code, nor the Go code. The idea wasn't
to get precise benchmark results, the goal was to get an idea of how
much faster Go was in a real life situation. The other goal was to
evaluate the amount of work needed to write web APIs in Go for someone
who already knows the language.</p>

<p>At the end of the day the API implemented in Go is more than 50x faster than
the Ruby version. Interesting enough, writing the code and tests for the
Go API was pretty close to the Ruby experience (more on that later).
50X performance gain, including high concurrency support might be a very
good argument to start using some Go when it makes sense.</p>

<p>I documented my experiment on <a href="https://plus.google.com/101114877505962271216/posts/PeZk8FY3PWY">Google+</a>, click the following screenshot to read more.</p>

<p><a href="https://plus.google.com/101114877505962271216/posts/PeZk8FY3PWY"><img src="/images/matt_aimonetti-golang_vs_ruby_api_exp.png" alt="Matt Aimonetti's Go vs Ruby post on Google+" /></a></p>
]]></content>
  </entry>
  
</feed>
